<?php
/**
 * Asset helper functions.
 *
 * Provides utility functions for working with plugin assets including
 * paths, URLs, versions, and dependencies generated by @wordpress/scripts.
 *
 * @package GunitaPlugin
 */

namespace GunitaPlugin;

/**
 * Class Asset
 *
 * This class provides helper functions for working with assets built
 * by @wordpress/scripts. It includes internal caching to minimize file
 * system operations and improve performance.
 *
 * All methods are static as this is a utility class with no instance state.
 */
class Asset {

	/**
	 * Cache for asset file data to avoid repeated file reads.
	 *
	 * @var array<string, array>
	 */
	private static $asset_cache = [];

	/**
	 * Default asset structure for type safety.
	 *
	 * @var array
	 */
	private const ASSET_DEFAULTS = [
		'dependencies' => [],
		'version'      => GUNITA_PLUGIN_VERSION,
	];

	/**
	 * Sanitize a file name to prevent path traversal.
	 *
	 * @param string $file File name to sanitize.
	 * @return string Sanitized file name.
	 */
	private static function sanitize_file_name( string $file ): string {
		// Use basename to prevent path traversal.
		$file = basename( $file );
		// Only allow alphanumeric, hyphens, and underscores.
		$file = preg_replace( '/[^a-zA-Z0-9_-]/', '', $file );
		return $file;
	}

	/**
	 * Get the filesystem path to an asset file.
	 *
	 * @param string $file The file name without extension.
	 * @param string $ext  Optional. The file extension. Default empty string.
	 * @return string The full filesystem path to the asset file.
	 */
	public static function get_file_path( string $file, string $ext = '' ): string {
		$file = self::sanitize_file_name( $file );
		return GUNITA_PLUGIN_PATH . '/build/' . $file . ( $ext ? '.' . $ext : '' );
	}

	/**
	 * Get the URL to an asset file.
	 *
	 * @param string $file The file name without extension.
	 * @param string $ext  Optional. The file extension. Default empty string.
	 * @return string The full URL to the asset file.
	 */
	public static function get_file_url( string $file, string $ext = '' ): string {
		$file = self::sanitize_file_name( $file );
		return GUNITA_PLUGIN_URL . '/build/' . $file . ( $ext ? '.' . $ext : '' );
	}

	/**
	 * Get the asset registry data.
	 *
	 * Reads the .asset.php file generated by @wordpress/scripts which contains
	 * version and dependency information. Results are cached internally to
	 * minimize file system operations.
	 *
	 * @param string $file The file name without extension.
	 * @return array{version: string, dependencies: array<string>} The asset registry data.
	 */
	public static function get_file_asset( string $file ): array {
		// Check cache first - avoids repeated file reads.
		if ( isset( self::$asset_cache[ $file ] ) ) {
			return self::$asset_cache[ $file ];
		}

		$asset_file      = $file . '.asset.php';
		$asset_file_path = self::get_file_path( $asset_file );

		// Check if the asset registry file exists.
		if ( ! is_readable( $asset_file_path ) ) {
			// Log the error in debug mode.
			if ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {
				// phpcs:ignore WordPress.PHP.DevelopmentFunctions.error_log_error_log
				error_log(
					sprintf(
						'GunitaPlugin: Asset file not found: %s. Run "pnpm run build" to generate assets.',
						$asset_file
					)
				);
			}

			// Cache the default to avoid repeated file checks.
			self::$asset_cache[ $file ] = self::ASSET_DEFAULTS;
			return self::ASSET_DEFAULTS;
		}

		// Load and cache the asset data.
		$asset_data = require $asset_file_path;

		// Ensure proper structure and merge with defaults.
		$asset_data = array_merge( self::ASSET_DEFAULTS, (array) $asset_data );

		// Cache for subsequent calls.
		self::$asset_cache[ $file ] = $asset_data;

		return $asset_data;
	}

	/**
	 * Get the version of an asset file.
	 *
	 * @param string $file The file name without extension.
	 * @return string The version string, or plugin version as fallback.
	 */
	public static function get_file_version( string $file ): string {
		$asset = self::get_file_asset( $file );
		return $asset['version'] ?? GUNITA_PLUGIN_VERSION;
	}

	/**
	 * Get the dependencies of an asset file.
	 *
	 * @param string $file The file name without extension.
	 * @return array<string> Array of dependency handles.
	 */
	public static function get_file_dependencies( string $file ): array {
		$asset = self::get_file_asset( $file );
		return $asset['dependencies'] ?? [];
	}

	/**
	 * Check if an asset file exists and is readable.
	 *
	 * Useful for conditional loading of optional assets.
	 *
	 * @param string $file File name without extension.
	 * @param string $ext  File extension (e.g., 'js', 'css'). Default 'js'.
	 * @return bool True if file exists and is readable.
	 */
	public static function asset_exists( string $file, string $ext = 'js' ): bool {
		$file_path = self::get_file_path( $file, $ext );
		return is_readable( $file_path );
	}

	/**
	 * Enqueue a script with automatic dependency and version management.
	 *
	 * This is a convenience method that wraps wp_enqueue_script() with
	 * automatic handling of dependencies and versioning from the .asset.php file.
	 *
	 * @param string $handle  Unique script handle.
	 * @param string $file    File name without extension.
	 * @param array  $args    {
	 *     Optional. Additional arguments.
	 *
	 *     @type bool   $in_footer Whether to enqueue in footer. Default true.
	 *     @type string $strategy  Loading strategy (defer/async). Default 'defer' (WP 6.3+).
	 *     @type array  $localize  Data to localize with wp_localize_script(). Default empty.
	 * }
	 * @return bool True if the script was enqueued successfully.
	 */
	public static function enqueue_script( string $handle, string $file, array $args = [] ): bool {
		$defaults = [
			'in_footer' => true,
			'strategy'  => 'defer',
			'localize'  => [],
		];

		$args = wp_parse_args( $args, $defaults );

		// Check if file exists.
		if ( ! self::asset_exists( $file, 'js' ) ) {
			if ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {
				// phpcs:ignore WordPress.PHP.DevelopmentFunctions.error_log_error_log
				error_log(
					sprintf(
						'GunitaPlugin: Attempted to enqueue non-existent script: %s',
						$file
					)
				);
			}
			return false;
		}

		$enqueue_args = [
			$handle,
			self::get_file_url( $file, 'js' ),
			self::get_file_dependencies( $file ),
			self::get_file_version( $file ),
			$args,
		];

		wp_enqueue_script( ...$enqueue_args );

		// Handle localization if provided.
		if ( ! empty( $args['localize'] ) && is_array( $args['localize'] ) ) {
			foreach ( $args['localize'] as $object_name => $data ) {
				wp_localize_script( $handle, $object_name, $data );
			}
		}

		return true;
	}

	/**
	 * Enqueue a stylesheet with automatic dependency and version management.
	 *
	 * This is a convenience method that wraps wp_enqueue_style() with
	 * automatic handling of dependencies and versioning from the .asset.php file.
	 *
	 * @param string $handle Unique style handle.
	 * @param string $file   File name without extension.
	 * @param array  $args   {
	 *     Optional. Additional arguments.
	 *
	 *     @type string $media Media for which this stylesheet is defined. Default 'all'.
	 * }
	 * @return bool True if the style was enqueued successfully.
	 */
	public static function enqueue_style( string $handle, string $file, array $args = [] ): bool {
		$defaults = [
			'media' => 'all',
		];

		$args = wp_parse_args( $args, $defaults );

		// Check if file exists.
		if ( ! self::asset_exists( $file, 'css' ) ) {
			if ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {
				// phpcs:ignore WordPress.PHP.DevelopmentFunctions.error_log_error_log
				error_log(
					sprintf(
						'GunitaPlugin: Attempted to enqueue non-existent stylesheet: %s',
						$file
					)
				);
			}
			return false;
		}

		wp_enqueue_style(
			$handle,
			self::get_file_url( $file, 'css' ),
			self::get_file_dependencies( $file ),
			self::get_file_version( $file ),
			$args['media']
		);

		return true;
	}
}
